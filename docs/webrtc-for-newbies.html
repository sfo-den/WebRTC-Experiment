<!DOCTYPE html>
<html id="home" lang="en">

<head>
    <title>WebRTC for newbies! ® Muaz Khan</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="author" type="text/html" href="https://plus.google.com/100325991024054712503">
    <meta name="author" content="Muaz Khan">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css" />
    <style>
        html {
            background: #eee;
        }

        body {
            font-family: "Inconsolata", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace;
            font-size: 1.2em;
            line-height: 1.2em;
            margin: 0;
        }

        article, footer {
            display: block;
            max-width: 900px;
            min-width: 360px;
            width: 80%;
        }

        article {
            background: #fff;
            border: 1px solid;
            border-color: #ddd #aaa #aaa #ddd;
            margin: 2.5em auto 0 auto;
            padding: 2em;
        }

        h1 {
            margin-top: 0;
        }

        article p:first-of-type {
            margin-top: 1.6em;
        }

        article p:last-child {
            margin-bottom: 0;
        }

        footer {
            margin: 0 auto 2em auto;
            text-align: center;
        }

            footer a {
                color: #666;
                font-size: inherit;
                padding: 1em;
                text-decoration: none;
                text-shadow: 0 1px 1px #fff;
            }

                footer a:hover, footer a:focus {
                    color: #111;
                }

        h1, h2 {
            border-bottom: 1px solid black;
            display: inline;
            font-weight: normal;
            line-height: 36px;
            padding: 0 0 3px 0;
        }

        a {
            color: #2844FA;
            text-decoration: none;
        }

            a:hover, a:focus {
                color: #1B29A4;
            }

            a:active {
                color: #000;
            }

        :-moz-any-link:focus {
            border: 0;
            color: #000;
        }

        ::selection {
            background: #ccc;
        }

        ::-moz-selection {
            background: #ccc;
        }

        button, input[type=button] {
            -moz-border-radius: 3px;
            -moz-transition: none;
            -webkit-transition: none;
            background: #0370ea;
            background: -moz-linear-gradient(top, #008dfd 0, #0370ea 100%);
            background: -webkit-linear-gradient(top, #008dfd 0, #0370ea 100%);
            border: 1px solid #076bd2;
            border-radius: 3px;
            color: #fff;
            display: inline-block;
            font-family: inherit;
            font-size: .8em;
            line-height: 1.3;
            padding: 5px 12px;
            text-align: center;
            text-shadow: 1px 1px 1px #076bd2;
            font-size: 1.5em;
        }

            button:hover, input[type=button]:hover {
                background: rgb(9, 147, 240);
            }

            button:active, input[type=button]:active {
                background: rgb(10, 118, 190);
            }

            button[disabled], input[type=button][disabled] {
                background: none;
                border: 1px solid rgb(187, 181, 181);
                color: gray;
                text-shadow: none;
            }

        strong {
            color: rgb(204, 14, 14);
            font-family: inherit;
            font-weight: normal;
        }

        tr, td, th {
            vertical-align: top;
            padding: .7em 1.4em;
            border-top: 1px dotted #BBA9A9;
            border-right: 1px dotted #BBA9A9;
        }

        table {
            width: 100%;
        }

        blockquote {
            margin: 1em 0;
        }
		img {
			width: 100%;
		}
    </style>
    <!-- for HTML5 el styling -->
    <script>
        document.createElement('article');
        document.createElement('footer');
    </script>
</head>

<body>
    <article>
    <a href="https://www.webrtc-experiment.com/" style="border-bottom: 1px solid #2844FA; font-size: 1.2em; position: absolute; text-decoration: none;right:0;top:0;">↑ WEBRTC EXPERIMENTS</a>

    <h1>WebRTC for newbies!
        </h1>
        <p>
            <span>Copyright © 2013</span>
            <a href="https://github.com/muaz-khan" target="_blank">Muaz Khan</a><span>&lt;</span><a href="http://twitter.com/muazkh" target="_blank">@muazkh</a><span>&gt;.</span>
        </p>

        <section class="plusone-gplus">
            <div class="g-plusone" data-href="https://www.webrtc-experiment.com/"></div>
        </section>

        <table style="width: 100%;">
            <tr>
                <td>If you're newcomer, newbie or beginner; you're suggested to try <a href="https://github.com/muaz-khan/WebRTC-Experiment/tree/master/RTCMultiConnection" target="_blank">RTCMultiConnection.js</a> or <a href="https://github.com/muaz-khan/WebRTC-Experiment/tree/master/DataChannel" target="_blank">DataChannel.js</a> libraries.
                </td>
            </tr>
        </table>



        <table>
            <tr>
                <td>The exchange of real-time media between two browsers follows this process:
                </td>
                </td>
		
		<tr>
            <td>
                <ol>
                    <li>At the media source, input devices are opened for capture. <small>( getUserMedia )</small>
                    </li>

                    <li>Media from the input devices is encoded into packets that are transmitted across the network.
                    </li>

                    <li>At the media destination, the packets are decoded and formed into a media stream.
                    </li>

                    <li>The media stream is sent to output devices. <small>( onaddstream )</small>
                    </li>
                </ol>
            </td>
        </tr>
            <tr>
                <td>
                    <img src="http://html5labs.interoperabilitybridges.com/cu-rtc-web/overview.png" alt="WebRTC Experiments">
                </td>
            </tr>
            <tr>
                <td>An application that wishes to enable two-way audio and video communications between peers can create four media streams (i.e. 4 RTP streams):
				<ol>
                    <li>An audio stream in each direction, <small>(i.e. outgoing/incoming audio RTP streams)</small>
                    </li>

                    <li>A video stream in each direction. <small>(i.e. outgoing/incoming video RTP streams)</small>
                    </li>
                </ol>
                </td>
            </tr>
            <tr>
                <td>
                    <h2>Any installation needed on the server?</h2>
                </td>
            </tr>
            <tr>
                <td>
                    (Unfortunately) A signaling gateway. ICE server lies in that gateway.
                </td>
            </tr>
            <tr>
                <td>
                    A media server for large scale applications:

                    <ol>
                        <li>to store recorded media streams (audio/video/files/text/etc.) or data</li>
                        <li>to make SIP calls to PSTN (legacy) networks</li>
                        <li>
                            to transcode/mix/merge streams
                        </li>
                    </ol>
                    obviously you need a media server and many installations!
                </td>
            </tr>
			
			<tr>
                <td>
                    So there are three kinds of concrete servers:

                    <ol>
                        <li>Signalling Server (SIP,XMPP,WebSocket,Socket.io,XHR,etc.)</li>
                        <li>ICE Servers (STUN,TURN)</li>
                        <li>Media Servers (Asterisk, etc.)</li>
                    </ol>
                    First two are mandatory for each application.
                </td>
            </tr>

            <tr>
                <td>
                    <h2>I'm confused about node.js!
                    </h2>
                </td>
            </tr>

            <tr>
                <td>
                    It can be your custom signaling gateway. It needs installations; server side work and more!
                </td>
            </tr>

            <tr>
                <td>
                    It is suggested to use Firebase, PubNub or Pusher for signaling until you get mature!
                </td>
            </tr>

            <tr>
                <td>
                    <h2>What is signaling and why it is needed?</h2>
                </td>
            </tr>

            <tr>
                <td>Interoperable real-time media between browsers uses RTP. 
                </td>
            </tr>

            <tr>
                <td>RTP depends on the existence of a signaling channel to establish a common understanding of the meaning of packets. 
                </td>
            </tr>

            <tr>
                <td>This includes identification of different streams, codecs, and codec parameters.
                </td>
            </tr>

            <tr>
                <td>Applications that establish peer-to-peer transports require that the IP addresses of a peer are signaled to the remote peer.
                </td>
            </tr>

            <tr>
                <td>Each real-time port consists of an IP address, a port number, a username fragment and password. This information is exchanged with the remote peer using whatever signaling mechanism is chosen by the application.
                </td>
            </tr>

            <tr>
                <td>In order to establish a transport between a local peer and remote peer, the following process is applied:
                </td>
            </tr>

            <tr>
                <td>
                    <ol>
                        <li>The local peer opens one or more real-time ports. <small>( RTP )</small>
                        </li>

                        <li>The local peer then has to learn of the ports that its remote peer has opened. This uses a signaling channel specific to the application. For instance, a web application could use previously HTTP requests or Websockets connections for this purpose.
                        </li>

                        <li>A process of discovery is used to find a local and remote port pair (a candidate pair) that can exchange UDP packets. One or more connectivity checks are made from different local ports toward different remote ports. A successful connectivity check indicates that packets can reach the peer and that the peer consents to receive packets.
                        </li>

                        <li>Finally, a real-time transport is established on the pair of ports. A security context is established so that secured media packets are able to flow in both directions between peers. Real-Time media streams can then be added to the transport.
                        </li>
                    </ol>
                </td>
            </tr>

            <tr>
                <td>
                    The initial connection between peers must be accomplished via an application server that provides for user discovery, communication, and Network Address Translation (NAT) with data streaming.
                </td>
            </tr>

            <tr>
                <td>
                    Signalling is the mechanism by which peers send control messages to each other for the purpose of establishing the communication protocol, channel, and method. These are not specified in the WebRTC standard. Rather, the developer may choose any messaging protocol (such as SIP or XMPP), and any two-way communication channel (such as WebSocket or XMLHttpRequest) in tandem with a persistent connection server API (like the <a href="https://developers.google.com/appengine/docs/python/channel/overview" target="_blank">Google Channel API</a>) for AppEngine.
                </td>
            </tr>

            <tr>
                <td>
                    <h2>What is SDP?</h2>
                </td>
            </tr>
			
			<tr>
                <td>
                    Session Description Protocol (SDP): A protocol that is used to announce sessions, manage session invitations, and perform other types of initiation tasks for multimedia sessions.
                </td>
            </tr>

            <tr>
                <td>A well-defined format for conveying sufficient information to discover and participate in a multimedia session ( <small>video conference</small> ).
                </td>
            </tr>

            <tr>
                <td>A multimedia session is a set of multimedia senders and receivers and the data streams flowing from senders to receivers. A multimedia conference is an example of a multimedia session.
                </td>
            </tr>

            <tr>
                <td>When initiating multimedia teleconferences, voice-over-IP calls, streaming video, or other sessions, there is a requirement to convey media details, transport addresses, and other session description metadata to the participants.
                </td>
            </tr>

            <tr>
                <td>SDP provides a standard representation for such information, irrespective of how that information is transported.
                </td>
            </tr>

            <tr>
                <td>Here is a simple (short) SDP ( <small>about 1000 to 2200 characters text message</small> ) generated by Google Chrome:
                </td>
            </tr>

            <tr>
                <td>
                    <pre>
a=group:BUNDLE <strong title="audio stream – microphone">audio</strong> <strong title="video stream – webcam">video</strong> <strong title="RTCDataChannel – files, images, text, any kind of data!">data</strong>
...
a=rtpmap:103 <strong title="ISAC">ISAC</strong>/16000
a=rtpmap:111 <strong title="opus audio codec">opus</strong>/48000
a=rtpmap:0 <strong title="PCMU">PCMU</strong>/8000
...
a=rtpmap:100 <strong title="VP8">VP8</strong>/90000
...
</pre>
                </td>
            </tr>

            <tr>
                <td>
                    <img src="https://sites.google.com/site/muazkh/how-webrtc-offer-answer-model-works.png" alt="How offer/answer model works in WebRTC?">
                </td>
            </tr>


            <tr>
                <td>Cross browser declaration:
                </td>
            </tr>

            <tr>
                <td>
                    <pre>
SessionDescription = <strong title="Chrome implementation">RTCSessionDescription</strong> || <strong title="Firefox implementation">mozRTCSessionDescription</strong>
</pre>
                </td>
            </tr>

            <tr>
                <td>He is a simple cross-browser "peer.createAnswer" API implementation:
                </td>
            </tr>

            <tr>
                <td>
                    <pre>
offerSDP = new <strong title="Chrome implementation of SessionDescription">SessionDescription</strong>(offerSDP);
peerConnection.<strong title="Setting remote description on both Firefox and Chrome">setRemoteDescription</strong>(offerSDP);

peerConnection.<strong title="Creating answer SDP on both Firefox and Chrome">createAnswer</strong>(function (sessionDescription) {
    peerConnection.<strong title="Setting local description on both Firefox and Chrome">setLocalDescription</strong>(sessionDescription);
}, null, constraints);
</pre>
                </td>
            </tr>

            <tr>
                <td>
                    <h2>How to order WebRTC code?</h2>
                </td>
            </tr>

            <tr>
                <td>First of all; create "offer sdp" by calling <code>peerConnection.createOffer</code>:
                </td>
            </tr>

            <tr>
                <td>
                    <pre>
offerer.<strong title="Creating offer SDP on both Firefox and Chrome">createOffer</strong>(function (offerSDP) {
    offerer.<strong title="Setting local description on both Firefox and Chrome">setLocalDescription</strong>(offerSDP);
    // use XHR/WebSocket/etc. to exchange offer-sdp with other peer(s)
}, null, constraints);
</pre>
                </td>
            </tr>

            <tr>
                <td>On the "answerer" side, set "remote descriptions" using "offer sdp":
                </td>
            </tr>

            <tr>
                <td>
                    <pre>
<strong title="Offer SDP is passed from offerer via XHR/WebSocket/etc.">offerSDP</strong> = new <strong title="Chrome implementation of SessionDescription">SessionDescription</strong>(<strong title="Offer SDP is passed from offerer via XHR/WebSocket/etc.">offerSDP</strong>);
answerer.<strong title="Setting remote description on both Firefox and Chrome">setRemoteDescription</strong>(<strong title="Offer SDP is passed from offerer via XHR/WebSocket/etc.">offerSDP</strong>);
</pre>
                </td>
            </tr>

            <tr>
                <td>And then create "answer sdp":
                </td>
            </tr>

            <tr>
                <td>
                    <pre>
answerer.<strong title="Creating answer SDP on both Firefox and Chrome">createAnswer</strong>(function (answerSDP) {
    answerer.<strong title="Setting local description on both Firefox and Chrome">setLocalDescription</strong>(answerSDP);
    
    // use XHR/WebSocket/etc. to exchange answer-sdp with "offerer"
}, null, constraints);
</pre>
                </td>
            </tr>

            <tr>
                <td>On the offerer side, set remote descriptions using "answer sdp":
                </td>
            </tr>

            <tr>
                <td>
                    <pre>
<strong title="Answer SDP is passed from answerer via XHR/WebSocket/etc.">answerSDP</strong> = new <strong title="Chrome implementation of SessionDescription">SessionDescription</strong>(<strong title="Answer SDP is passed from answerer via XHR/WebSocket/etc.">answerSDP</strong>);
offerer.<strong title="Setting remote description on both Firefox and Chrome">setRemoteDescription</strong>(<strong title="Answer SDP is passed from answerer via XHR/WebSocket/etc.">answerSDP</strong>);
</pre>
                </td>
            </tr>

            <tr>
                <td>
                    <h2>What is ICE and is it mandatory?</h2>
                </td>
            </tr>

            <tr>
                <td>The purpose of the ICE protocol is to establish a media path.
                </td>
            </tr>

            <tr>
                <td>
                    <blockquote style="margin-left: 2em; border-left: 5px solid gray; padding-left: 1em;">
                        "Making a call starts by sending a SIP INVITE message with an SDP describing on which IP address(es) and port(s) the application can receive audio and/or video packets. These addresses and ports are known as candidates."
                    </blockquote>
                </td>
            </tr>

            <tr>
                <td>Specifically, a candidate is an IP address and port at which one peer can receive data from another peer.
                </td>
            </tr>

            <tr>
                <td>There are 3 types of candidates:
                </td>
            </tr>

            <tr>
                <td>
                    <h2>1) Local candidate:</h2>
                </td>
            </tr>

            <tr>
                <td>A local IP address of the client.
                </td>
            </tr>

            <tr>
                <td>
                    <h2>2) Reflexive or STUN candidates</h2>
                </td>
            </tr>

            <tr>
                <td>An IP address of the client's NAT (assuming they are only behind a single NAT). These are determined from another entity, and then communicated back to the client.
                </td>
            </tr>

            <tr>
                <td>
                    <h2>3) Relay or TURN candidate</h2>
                </td>
            </tr>

            <tr>
                <td>An address on a relay server that has been allocated for use by the client.
                </td>
            </tr>

            <tr>
                <td>
                    <blockquote style="margin-left: 2em; border-left: 5px solid gray; padding-left: 1em;">
                        "Traffic can always be sent successfully using relay candidates, unless a firewall blocks all traffic towards the client, in which case no legitimate firewall traversal technique can ever work. The problem with using relay candidates, however, is that they require server resources, and relayed traffic introduces additional delay, loss and jitter in the traffic stream."
                    </blockquote>
                </td>
            </tr>

            <tr>
                <td>You can use <code>peerConnection.<strong>onicecandidate</strong></code> event to get ICE generated for local peer. You can send those ICE via XHR/WebSocket/WebSync toward destination.
                </td>
            </tr>

            <tr>
                <td>
                    <pre>
a=candidate:<strong title="candidate number">1</strong> 1 UDP 2130706431 <strong title="ip address">192.168.1.102</strong> 1816 typ <strong>host</strong>
a=candidate:<strong title="candidate number">2</strong> 1 UDP 2130706431 <strong title="ip address">23.45.1.102</strong> 3456 typ <strong>srflx</strong>
a=candidate:<strong title="candidate number">3</strong> 1 UDP 2130706431 <strong title="ip address">34.66.1.102</strong> 5678 typ <strong>relay</strong>
</pre>
                </td>
            </tr>

            <tr>
                <td>
                    <blockquote style="margin-left: 2em; border-left: 5px solid gray; padding-left: 1em;">
                        "Once the callee has sent its ICE candidates, and once the caller receives them, they each start the ICE connectivity checks. At this point, both the parties know about their peer’s potential candidates. Each possible pair of local and remote candidates is formed, creating a number of candidate pairs. A connectivity check is done by sending STUN messages from the local candidate to the remote candidate of each pair, starting with the highest priority (i.e. most preferred) candidate pair first. Both parties exchange STUN messages in this way to determine the best possible candidate pair that they can use to communicate. Once a valid (i.e. successful) message has been sent both ways on a single candidate pair, the connectivity check can stop and media can be sent/received using that candidate pair. "
                    </blockquote>
                </td>
            </tr>

            <tr>
                <td>Now if the call has been established, both the caller and callee send media to/from their successful candidate addresses. (usually using RTP protocol)
                </td>
            </tr>

            <tr>
                <td>
                    <h2>onaddstream event:</h2>
                </td>
            </tr>

            <tr>
                <td>
                    <code>peerConnection.<strong>onaddstream</strong></code> fires as soon as local peer gets clue of the remote stream. Remember, it takes a few seconds for remote stream to start flowing. You can check whether remote stream started flowing or not using something like this:
                </td>
            </tr>

            <tr>
                <td>
                    <pre>
if (chrome) video.src = webkitURL.createObjectURL( event.stream )
if (firefox) video.mozSrcObject = event.<strong>stream</strong>;
if (!(video.<strong>readyState</strong> &lt;= HTMLMediaElement.<strong>HAVE_CURRENT_DATA</strong> 
    || video.<strong>paused</strong>
    || video.<strong>currentTime</strong> &lt;= 0))  { }
</pre>
                </td>
            </tr>

        </table>

        <section style="border: 1px solid rgb(189, 189, 189); margin: 1em 3em; border-radius: .2em;">
                <h2 id="feedback" style="padding: .2em .4em; border-bottom: 1px solid rgb(189, 189, 189);">Feedback</h2>
                <div>
                    <textarea id="message" style="height: 8em; margin: .2em; width: 98%; border: 1px solid rgb(189, 189, 189); outline: none; resize: vertical;" placeholder="Have any message? Suggestions or something went wrong?"></textarea>
                </div>
                <button id="send-message" style="font-size: 1em;">Send Message</button>
            </section>
    </article>
    <footer>
        <p>
            <a href="https://www.webrtc-experiment.com/" target="_blank">WebRTC Experiments!</a>©
                <a href="https://plus.google.com/100325991024054712503" rel="author" target="_blank">Muaz Khan</a>, <span>2013 </span>»
                <a href="mailto:muazkh@gmail.com" target="_blank">Email</a>»
                <a href="http://twitter.com/muazkh" target="_blank">@muazkh</a>»
                <a href="https://github.com/muaz-khan" target="_blank">Github</a>
        </p>
    </footer>
    <script src="https://www.webrtc-experiment.com/common.js"> </script>
</body>
</html>
